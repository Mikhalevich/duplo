package main

import (
	"errors"
	"fmt"
	"net/url"
	"path"
	"strconv"

	"github.com/Mikhalevich/argparser"
	"github.com/Mikhalevich/duplo/commands"
)

type Params struct {
	Host        string `json:"host"`
	Storage     string `json:"storage"`
	command     string
	isPermanent bool
}

func NewParams() *Params {
	return &Params{
		Host:        "http://duplo",
		Storage:     "common",
		isPermanent: false,
	}
}

func join(base string, elem ...string) string {
	u, err := url.Parse(base)
	if err != nil {
		fmt.Println(err)
	}
	for _, e := range elem {
		u.Path = path.Join(u.Path, e)
	}

	resURL := u.String()
	if resURL[:len(resURL)-1] != "/" {
		resURL = fmt.Sprintf("%s/", resURL)
	}
	return resURL

}

func (p *Params) makeBaseURL() string {
	u := join(p.Host, p.Storage)
	if p.isPermanent {
		u = join(u, "permanent")
	}
	return u
}

func (p *Params) listURL() string {
	u := join(p.Host, "api", p.Storage)
	if p.isPermanent {
		u = join(u, "permanent")
	}
	return u
}

func (p *Params) uploadURL() string {
	return join(p.makeBaseURL(), "upload")
}

func (p *Params) downloadURL(fileName string) string {
	return join(p.makeBaseURL(), fileName)
}

func (p *Params) files() ([]string, error) {
	if argparser.NArg() <= 1 {
		return []string{}, errors.New("No files for upload specified")
	}

	files := make([]string, 0, argparser.NArg())
	for i := 1; i < argparser.NArg(); i++ {
		files = append(files, argparser.Arg(i))
	}

	return files, nil
}

func (p *Params) list() error {
	files, err := commands.List(p.listURL())
	if err != nil {
		return err
	}

	for i, f := range files {
		fmt.Printf("%d => %s\n", i+1, f.Name)
	}

	return nil
}

func (p *Params) download() error {
	numbers, err := p.files()
	if err != nil {
		return err
	}

	files, err := commands.List(p.listURL())
	if err != nil {
		return err
	}

	processed := make(map[int]bool)

	for _, numStr := range numbers {
		number, err := strconv.Atoi(numStr)
		if err != nil {
			fmt.Printf("Invalid number %s\n", numStr)
			continue
		}

		if (number <= 0) || (number > len(files)) {
			fmt.Printf("No file with index %d\n", number)
			continue
		}

		if processed[number] {
			fmt.Printf("Already processed %d\n", number)
			continue
		}

		file, err := commands.Download(p.downloadURL(files[number-1].Name))
		if err != nil {
			return err
		}

		processed[number] = true
		fmt.Printf("Downloaded: %s\n", file)
	}

	return nil
}

func (p *Params) upload() error {
	files, err := p.files()
	if err != nil {
		return err
	}
	err = commands.Upload(p.uploadURL(), files)
	if err != nil {
		return err
	}

	fmt.Println("Uploaded...")
	return nil
}

func (p *Params) runCommand() error {
	switch p.command {
	case "list":
		return p.list()

	case "get":
		return p.download()

	case "push":
		return p.upload()
	}

	return fmt.Errorf("Unknown commnad %s", p.command)
}

func normalizeURL(baseURL string) (string, error) {
	u, err := url.Parse(baseURL)
	if err != nil {
		return "", err
	}

	if u.Scheme == "" {
		baseURL = "http://" + baseURL
	}

	return baseURL, nil
}

func loadParams() (*Params, error) {
	host := argparser.String("h", "", "host")
	storage := argparser.String("s", "", "storage name to upload")
	isPermanent := argparser.Bool("p", false, "user permanent storage")

	basicParams := NewParams()
	params, err, gen := argparser.Parse(basicParams)

	if gen {
		return nil, errors.New("Config should be autogenerated")
	}

	p := params.(*Params)

	if argparser.NArg() <= 0 {
		return nil, errors.New("No command specified")
	}

	p.command = argparser.Arg(0)

	if *host != "" {
		u, err := normalizeURL(*host)
		if err != nil {
			return nil, err
		}
		p.Host = u
	}

	if *storage != "" {
		p.Storage = *storage
	}
	p.isPermanent = *isPermanent

	if p.Host == "" {
		return nil, errors.New("Host is invalid")
	}

	if p.Storage == "" {
		return nil, errors.New("Storage name is invalid")
	}

	return p, err
}

func main() {
	p, err := loadParams()
	if err != nil {
		fmt.Println(err)
		return
	}

	err = p.runCommand()
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println("Done...")
}
