package main

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"

	"github.com/Mikhalevich/argparser"
)

const (
	uploadPathTemplate          = "%s/upload/"
	uploadPermanentPathTemplate = "%s/permanent/upload/"
)

type Params struct {
	Host        string `json:"host"`
	Storage     string `json:"storage"`
	command     string
	isPermanent bool
}

func NewParams() *Params {
	return &Params{
		Host:        "http://duplo",
		Storage:     "common",
		isPermanent: false,
	}
}

func (p *Params) uploadURL() string {
	template := uploadPathTemplate
	if p.isPermanent {
		template = uploadPermanentPathTemplate
	}
	path := fmt.Sprintf(template, p.Storage)
	return fmt.Sprintf("%s/%s", p.Host, path)
}

func (p *Params) files() ([]string, error) {
	if argparser.NArg() <= 1 {
		return []string{}, errors.New("No files for upload specified")
	}

	files := make([]string, 0, argparser.NArg())
	for i := 1; i < argparser.NArg(); i++ {
		files = append(files, argparser.Arg(i))
	}

	return files, nil
}

func loadParams() (*Params, error) {
	host := argparser.String("h", "", "host")
	storage := argparser.String("s", "", "storage name to upload")
	isPermanent := argparser.Bool("p", false, "user permanent storage")

	basicParams := NewParams()
	params, err, gen := argparser.Parse(basicParams)

	if gen {
		return nil, errors.New("Config should be autogenerated")
	}

	p := params.(*Params)

	if argparser.NArg() <= 0 {
		return nil, errors.New("No command specified")
	}

	p.command = argparser.Arg(0)

	if *host != "" {
		p.Host = *host
	}

	if *storage != "" {
		p.Storage = *storage
	}
	p.isPermanent = *isPermanent

	if p.Host == "" {
		return nil, errors.New("Host is invalid")
	}

	if p.Storage == "" {
		return nil, errors.New("Storage name is invalid")
	}

	return p, err
}

func runCommand(params *Params) error {
	switch params.command {
	case "list":
		return errors.New("not implemented yet")

	case "get":
		return errors.New("not implemented yet")

	case "push":
		files, err := params.files()
		if err != nil {
			return err
		}
		return upload(params.uploadURL(), files)
	}

	return fmt.Errorf("Unknown commnad %s", params.command)
}

func makeBodyReader(files []string) (io.Reader, string, error) {
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	for _, fileName := range files {
		file, err := os.Open(fileName)
		if err != nil {
			return nil, "", err
		}

		baseName := filepath.Base(fileName)
		part, err := writer.CreateFormFile(baseName, baseName)
		if err != nil {
			return nil, "", err
		}

		_, err = io.Copy(part, file)
		if err != nil {
			return nil, "", err
		}
	}

	err := writer.Close()
	if err != nil {
		return nil, "", err
	}

	return body, writer.FormDataContentType(), nil
}

func upload(url string, files []string) error {
	body, contentType, err := makeBodyReader(files)
	if err != nil {
		return err
	}

	request, err := http.NewRequest(http.MethodPost, url, body)
	if err != nil {
		return err
	}

	request.Header.Set("Content-Type", contentType)
	request.Close = true

	client := http.Client{}
	response, err := client.Do(request)
	if err != nil {
		return err
	}
	defer response.Body.Close()

	if response.StatusCode != http.StatusOK {
		return fmt.Errorf("Unable to upload file: %s", response.Status)
	}

	return nil
}

func main() {
	p, err := loadParams()
	if err != nil {
		fmt.Println(err)
		return
	}

	err = runCommand(p)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println("Done...")
}
